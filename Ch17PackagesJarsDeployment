CH 17 PACKAGES, JARS & DEPLOYMENT

- A Java program is a bunch of classes. 

Deployement options: 
- Local (executable JAR)

- Local / Remote Combination (client portion running on the user's local system, connected to a server)

- Remote (Enter app running on a server - ex. web browser)



---------Organizing Your Classes---------

- Definitely should separate source code and class files (A single directory with a pile of source code and class files is a mess)!


- Use the -d compiler option to organize. 

- With this scheme, you create a project directory. And inside that, you create a directory called 'source' and a directory called 'classes'.

- Save the source code (.java files) into the source directory. Save the classes (.class files) into the classes directory. 

Example: 

% cd MyProject/source
% javac -d ../classes  MyApp.java       // tells the compiler to put the compiled code (class files) into the classes directory.


% javac  -d ../classes  *.java    // *.java compiles ALL source files in the current directory 


- Running your code: 

% cd MyProject/classes      // run your program from the 'classes' directory. 
% java Mini     




--------Putting Java In A JAR----------

- JAR = Java Archive (based on the pkzip file format), and lets you bundle all of your classes together into a single JAR file. 

- Executable JAR = the end-user doesn't have to pull the class files out before running the program. 

- The user can run the app while the class files are still in the JAR. The trick is to create a 'manifest' file (which goes in the JAR, and holds info about the files in the JAR).



- To make a JAR executable, the manifest must tell the JVM which class has the main() method! 




--------Executable JAR----------

- When your class is in a package, the package directory structure must be inside the JAR.


Making an executable JAR: 

1. Make sure all of your class files are in the 'classes' directory. 


2. Create a manifest.txt file that states which class has the main() method. 

"Main-Class: MyApp" (don't put .class at the end)


3. Run the jar tool to create a JAR file that contains everything in the classes directory, plus the manifest. 

% cd MiniProject/classes

% jar -cvmf manifest.txt appl.jar *.class

OR 

% jar -cvmf manifest.txt appl.jar MyApp.class



- The JVM has to 'see' the JAR, so it must be in your classpath. The easiest way to make the JAR visible is to make your working directory the place where the JAR is. 


% cd MyProject/classes 

% java -jar app1.jar        

// '-jar' = tells the JVM you're giving it a JAR instead of a class. 


// 'app1.jar' = the JVM looks inside this JAR for a manifest with an entry for the 'main' class. If it doesn't find one, you get a runtime exception.





---------Packages----------

- Put your classes inside Packages (Packages prevent class name conflicts).

- Class ArrayList is technically java.util.ArrayList. 

- JButton is really javax.swing.JButton.

- Socket is really java.net.Socket.


- The best way to prevent name conflicts is to preface your packages with your reverse domain name. 

Example: 

com.headfirstbooks.Book;       

// com.headfirstbooks is the package name, Book is the class name (class name is always capitalized).




---------How To Put Your Class Into A Package--------

- You must put a class into a directory structure that matches the package hierarchy. 

To put your class in a package: 

1. Choose a package name (com.headfirstjava.PackageExercise).

2. Put a package statement in your class. 

- It must be the first statement in the source code file.  

Example: 

package com.headfirstjava;

3. Set up a matching directory structure. 

- Your class is truly in a package until you put the class in a matching directory structure. 

Example: 

If you typed 'com.headfirstjava.PackageExercise', you must put the PackageExercise source code in a directory named 'headfirstjava', which must be in a directory named 'com'.




---------Compiling with the -d (directory)---------

% cd MyProject/source (stay in the source directory!)

% javac  -d ../classes com/headfirstjava/PackageExercise.java


// '-d' tells the compiler to put the compiler code (class files) into the classes directory, within the right package structure. 


- To compile all the .java files in the com.headfirstjava package, use: 

% javac -d ../classes com/headfirstjava/*.java





---------Running Your Code---------

% cd MyProject/classes

% java com.headfirstjava.PackageExercise





----------JAR commands for listing and extracting--------

- 1. List the contents of the JAR. 

% jar -tf packEx.jar       // -tf = Table File (show me a table of the JAR files)


2. Extract the contents of a JAR (unjar)

% cd Skyler

% jar -xf packEx.jar          

// -xf = Extract File (similar to unzipping). You can see the META-INF directory and the com directory. 

// META-INF stands for meta information. The jar tool creates the META-INF directory as well as the MANIFEST.MF file (manifest files go into the MANIFEST.MF. 

// Manifest files doesn't go into the JAR, but the contents of it are put into the 'real' manifest - MANIFEST.MF. 





-----------JAVA WEB START (JWS)------------

- End-users launch a Java Web Start app by clicking on a link in a Web page. 

- Once the app downloads, it runs outside the browser, just like any other stand-alone Java app.

- A Java Web Start app is just an executable JAR that is distributed over the Web.




----------How JWS Works-----------

1. The client clicks on a Web page link to your JWS app (a .jnlp file).

<a href="MyApp.jnlp">Click</a>


2. The Web server (HTTP) gets the request and sends back a .jnlp file. 

-.jnlp file is an XML document that states the nameof the app's executable JAR file.


3. JWS (a small 'helper app' on the client) is stated up by the browser. The JWS helper app reads the .jnlp file, and asks the server for the MyApp.jar file. 


4. The Web server 'serves' up the requested .jar file.


5. JWS gets the JAR and starts the app by calling the specific main() method (just like an executable JAR).




-----------Servlets-----------

- Servlets are Java programs that run on an HTTP web server. 

- Servlet code is code that runs on the server, to do work as whatever the client requests.



------------Steps for making and running a Servlet----------

1. Find out where your servlets need to be placed. Your server needs to be able to 'see' them.



2. Get the servlets .jar and add it to your classpath. 

- You need the servlets classes packaged into the sevlets.jar file. 



3. Write a servlet class by extending HttpServlet.

public class MyServletA extends HttpServlet { ... }

- A typical servlet extends HttpServlet and overrides one or more servlet methods, such as doGet() or doPost(). 



4. Write an HTML page that invokes your servlet. 

<a href="servlets/MyServletA">This is an awesome servlet.</a>



5. Make your servlet and HTML page available to your server. 




-----------Enterprise JavaBeans (Enterprise application Server - J2EE): RMI on steroids-------------

- RMI is great for writing and running remote services, but not for a huge commerce sites (when a ton of people access the server at once).

- A J2EE server = includes both a web server and an Enterprise JavaBeans (EJB) server, so that you can deploy an application that includes both servlets and EJBs. 


- An EJB server adds a bunch of services that you don't get with straight RMI (things like transactions, security, concurrency, database management, and networking).




-----------Jini (RMI with wings)------------

- Jini uses RMI, and also gives you a few key features like adaptive discovery and self-healing networks.

- With Jini, the client only has to know one thing: the interface implemented by the service. 



Adaptive discovery in action.....

1. Jini lookup service is launched somewhere on the network, and announces itself using IP multicast. 


2. An already-running Jini service on another machine asks to be registered with this newly-announced lookup service. It registers by capability, rather than by name. It registers as the service interface it implements. It sends a serialized object to be placed in the lookup service. 


3. A client on the network wants something that implements the ScientificCalculator interface. It has no idea where that thing exists, so it asks the lookup service. 


4. The lookup service responds, since it does have something registered as a ScientificCalculator interface. 




Self-healing network in action.....

1. A Jini service has asked to register with the lookup service. The lookup service responds with a "lease". The newly-registered service must keep renewing the lease, or the lookup service assumes the service has gone offline. The lookup service wants to always present an accurate picture to the rest of the network about which services are available. 


2. The service goes offline (somebody shuts it down), so it fails to renew its lease with the lookup service. The lookup service drops it. 




-----------Assertions------------

- Assertions are like System.out.println() statements on steroids. At runtime, if you do nothing, the assert statements (you added to your code) will be ignored. 

- If you tell the JVM to enable your assertions, they will help you do your debugging, without changing a line of code!

- Leaving your assert statement codes can be really valuable when your code is already deployed in the field. 



How to make Assertions work: 

- Add assertion statements to your code wherever you believe that something must be true. 

Example: 

assert (height > 0);

// If true, program continues normally. If false, throw an AssertionError.


- You can add more code if you like: 

assert (height > 0) : "height = " + height + "weight = " + weight;



Compiling with assertions: 

javac TestDriveGame.java;



Running with assertions: 

java -ea TestDriveGame;





----------Anonymous & Static Nested Classes-----------

- A static nested class looks just like the non-static classes (except marked with the keyword 'static').


- Static nested classes still get access to any private members of the outer class, but only the ones that are also static. 


- Non-static inner classes are often referred to as inner classes. 



- Access modifiers = public, private, protected


- Use 'public' for classes, constants (static final variables) and methods that you're exposing to the other code and most constructors. 


- Use 'private' for all instance variables, and for methods you don't want outside code to call. 


- 'protected' alows subclasses to inherit the protected thing, even if those subclasses are outside the package of the superclass they extend. 'protected' access applies only to inheritance. 





------------Enumerations------------

- Enumeration = Sometimes, you want to create a set of constant values to represent the only valid values for a variable. 

- You can create your own constants by marking a variable 'static final'.


