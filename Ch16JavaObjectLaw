------Java Object Law for HashCode() and equals()-----

- The API docs for classObject state the rules you must follow: 

1. If two objects are equal, they must have matching hashcodes. 

2. If two objects are equal, calling equals on either object must return true. (ex. if (a.equals(b), then (b.equals(a) )

3. If you override equals(), you must override hashCode().



- a.equals(b) must also mean a.hashCode() == b.hashCode()

- a.hashCode() == b.hashCode() does not have to mean a.equals(b)




----------TreeSets and Sorting-----------

- TreeSet is similar to HashSet (it prevents duplicates).

- It works just like the sort() method (TreeSet uses each object's compareTo() method for the sort).

- Downside is that even if you don't need sorting, TreeSet takes a performance hit. 


Example: 

TreeSet<Song> songSet = new TreeSet<Song>();     

// Instantiate a TreeSet instead of a HashSet. Calling the no-arg TreeSet constructor means the set will use the Song object's compareTo() method for the sort.


songSet.addAll(songList);

// We can add all the songs from the HashSet using addAll() (or we can add the songs individually using SongSet.add() just like using ArrayList).



- TreeSet elements MUST be comparable.



---------To Use TreeSet---------

To use a TreeSet, one of these things must be true: 

1. The elements in the list must be of a type that implements Comparable. 

Example: 

class Book implements Comparable {
	String title;
	public Book (String t) {
		title = t;
	}

	public int compareTo(object b) {
		Book book = (Book) b:
		return (title.compareTo(book.title));
	}
}



2. You use the TreeSet's overloaded constructor that takes a Comparator. 

- TreeSet works like a sort() method. 

















